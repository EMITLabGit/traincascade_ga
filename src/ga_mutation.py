"""
This module implements the Haar Feature Mutator class that is used to mutate the offsprings generated after crossover.
"""

import numpy as np
import utils


class HaarFeatureMutator:
    """
    Class to mutate haar features to generate new and valid haar features
    Offsprings are generated after crossover and are mutated to generate new and valid offsprings
    Even if there are no mutations, this class also ensures that the offsprings are converted to valid haar features since
    the offsprings generated by crossover may not be valid haar features
    """

    def __init__(self, ga_instance):
        self.ga_instance = ga_instance

        # dispatcher dictionary for calling the appropriate feature mutation function
        self.feat_mutation_funcs = {
            1: self._mutate_feature_1,
            2: self._mutate_feature_2,
            3: self._mutate_feature_3,
            4: self._mutate_feature_4,
            5: self._mutate_feature_5
        }

        # x, w combinations
        self.combinations_x_w = ga_instance.haar_feature_sampler.combinations_x_w
        # x, hw combinations
        self.combinations_x_hw = ga_instance.haar_feature_sampler.combinations_x_hw
        # x, tw combinations
        self.combinations_x_tw = ga_instance.haar_feature_sampler.combinations_x_tw

    def _mutate_with_constraints_x_w(self, gene_x, gene_w, r_x, r_w):
        # sample x and w from the range of possible values which satisfy the constraint that x + w <= 24
        x, w = self.combinations_x_w[np.random.randint(
            0, self.combinations_x_w.shape[0])]

        # if both r_x and r_w are less than mutation probability, then mutate set x and w genes to the newly sampled valid values
        if r_x < self.ga_instance.mutation_probability and r_w < self.ga_instance.mutation_probability:
            gene_x, gene_w = x, w

        # else if only r_x is less than mutation probability, then mutate only x gene by sampling from the range of possible values and fixing w if constraint is violated
        elif r_x < self.ga_instance.mutation_probability:
            gene_x = x

        # else if only r_w is less than mutation probability, then mutate only w gene by sampling from the range of possible values and fixing x if constraint is violated
        elif r_w < self.ga_instance.mutation_probability:
            gene_w = w

        # set both x, w if constraint is violated
        if gene_x + gene_w > 24:
            gene_x, gene_w = x, w

        return gene_x, gene_w

    def _mutate_with_constraints_x_hw(self, gene_x, gene_w, r_x, r_w):
        # sample x and w from the range of possible values which satisfy the constraint that x + w <= 24 and w is even
        x, hw = self.combinations_x_hw[np.random.randint(
            0, self.combinations_x_hw.shape[0])]
        w = 2 * hw

        # if both r_x and r_w are less than mutation probability, then mutate set x and w genes to the newly sampled valid values
        if r_x < self.ga_instance.mutation_probability and r_w < self.ga_instance.mutation_probability:
            gene_x, gene_w = x, w

        # else if only r_x is less than mutation probability, then mutate only x gene by sampling from the range of possible values and fixing w if constraint is violated
        elif r_x < self.ga_instance.mutation_probability:
            gene_x = x

        # else if only r_w is less than mutation probability, then mutate only w gene by sampling from the range of possible values and fixing x if constraint is violated
        elif r_w < self.ga_instance.mutation_probability:
            gene_w = w

        # set both x, w if constraint is violated
        if gene_x + gene_w > 24 or gene_w % 2 != 0:
            gene_x, gene_w = x, w

        return gene_x, gene_w

    def _mutate_with_constraints_x_tw(self, gene_x, gene_w, r_x, r_w):
        # sample x and w from the range of possible values which satisfy the constraint that x + w <= 24 and w is divisible by 3
        x, tw = self.combinations_x_tw[np.random.randint(
            0, self.combinations_x_tw.shape[0])]
        w = 3 * tw

        # if both r_x and r_w are less than mutation probability, then mutate set x and w genes to the newly sampled valid values
        if r_x < self.ga_instance.mutation_probability and r_w < self.ga_instance.mutation_probability:
            gene_x, gene_w = x, w

        # else if only r_x is less than mutation probability, then mutate only x gene by sampling from the range of possible values and fixing w if constraint is violated
        elif r_x < self.ga_instance.mutation_probability:
            gene_x = x

        # else if only r_w is less than mutation probability, then mutate only w gene by sampling from the range of possible values and fixing x if constraint is violated
        elif r_w < self.ga_instance.mutation_probability:
            gene_w = w

        # set both x, w if constraint is violated
        if gene_x + gene_w > 24 or gene_w % 3 != 0:
            gene_x, gene_w = x, w

        return gene_x, gene_w

    def _mutate_feature_1(self, chromosome, idx):
        """Mutate the non feature type genes of the chromosome at the given index"""

        # first check and do mutation for the x, w genes since they are dependent on each other
        r_x, r_w = self.random_uniforms[idx][1], self.random_uniforms[idx][3]
        chromosome[1], chromosome[3] = self._mutate_with_constraints_x_hw(
            chromosome[1], chromosome[3], r_x, r_w)

        # now check and do mutation for the y, h genes since they are dependent on each other
        r_y, r_h = self.random_uniforms[idx][2], self.random_uniforms[idx][4]
        chromosome[2], chromosome[4] = self._mutate_with_constraints_x_w(
            chromosome[2], chromosome[4], r_y, r_h)

        return chromosome

    def _mutate_feature_2(self, chromosome, idx):
        """Mutate the non feature type genes of the chromosome at the given index"""

        # first check and do mutation for the x, w genes since they are dependent on each other
        r_x, r_w = self.random_uniforms[idx][1], self.random_uniforms[idx][3]
        chromosome[1], chromosome[3] = self._mutate_with_constraints_x_w(
            chromosome[1], chromosome[3], r_x, r_w)

        # now check and do mutation for the y, h genes since they are dependent on each other
        r_y, r_h = self.random_uniforms[idx][2], self.random_uniforms[idx][4]
        chromosome[2], chromosome[4] = self._mutate_with_constraints_x_hw(
            chromosome[2], chromosome[4], r_y, r_h)

        return chromosome

    def _mutate_feature_3(self, chromosome, idx):
        """Mutate the non feature type genes of the chromosome at the given index"""

        # first check and do mutation for the x, w genes since they are dependent on each other
        r_x, r_w = self.random_uniforms[idx][1], self.random_uniforms[idx][3]
        chromosome[1], chromosome[3] = self._mutate_with_constraints_x_tw(
            chromosome[1], chromosome[3], r_x, r_w)

        # now check and do mutation for the y, h genes since they are dependent on each other
        r_y, r_h = self.random_uniforms[idx][2], self.random_uniforms[idx][4]
        chromosome[2], chromosome[4] = self._mutate_with_constraints_x_w(
            chromosome[2], chromosome[4], r_y, r_h)

        return chromosome

    def _mutate_feature_4(self, chromosome, idx):
        """Mutate the non feature type genes of the chromosome at the given index"""

        # first check and do mutation for the x, w genes since they are dependent on each other
        r_x, r_w = self.random_uniforms[idx][1], self.random_uniforms[idx][3]
        chromosome[1], chromosome[3] = self._mutate_with_constraints_x_w(
            chromosome[1], chromosome[3], r_x, r_w)

        # now check and do mutation for the y, h genes since they are dependent on each other
        r_y, r_h = self.random_uniforms[idx][2], self.random_uniforms[idx][4]
        chromosome[2], chromosome[4] = self._mutate_with_constraints_x_tw(
            chromosome[2], chromosome[4], r_y, r_h)

        return chromosome

    def _mutate_feature_5(self, chromosome, idx):
        """Mutate the non feature type genes of the chromosome at the given index"""

        # first check and do mutation for the x, w genes since they are dependent on each other
        r_x, r_w = self.random_uniforms[idx][1], self.random_uniforms[idx][3]
        chromosome[1], chromosome[3] = self._mutate_with_constraints_x_hw(
            chromosome[1], chromosome[3], r_x, r_w)

        # now check and do mutation for the y, h genes since they are dependent on each other
        r_y, r_h = self.random_uniforms[idx][2], self.random_uniforms[idx][4]
        chromosome[2], chromosome[4] = self._mutate_with_constraints_x_hw(
            chromosome[2], chromosome[4], r_y, r_h)

        return chromosome

    def _mutate_chromosome(self, chromosome, idx):
        """
        Mutate the chromosome at the given index
        """

        # get the random uniform number at the given index
        random_uniform = self.random_uniforms[idx]

        # mutate the feature type gene
        if random_uniform[0] < self.ga_instance.mutation_probability:
            # mutate the feature type gene
            chromosome[0] = self.random_feature_types[idx]

        # mutate the rest of the genes in the chromosome based on the feature type
        chromosome = self.feat_mutation_funcs[chromosome[0]](chromosome, idx)

        return chromosome

    def mutate(self, offsprings):
        """
        Mutate the offsprings to generate new and valid offsprings
        """
        self.offspings = offsprings
        # self.original_offsprings = offsprings.copy()

        # generate random uniform numbers between 0 and 1 of the same shape as the offspring which will be used to decide whether to mutate a gene or not
        self.random_uniforms = np.random.uniform(0, 1, offsprings.shape)

        # generate feature types for each chromosome in the offspring
        self.random_feature_types = self.ga_instance.haar_feature_sampler.sample_feature_type(
            offsprings.shape[0])

        # for each chromosome in the offspring, mutate the chromosome based on the random uniform number at the same index
        for idx in range(offsprings.shape[0]):
            # mutate the chromosome based on the random uniform number
            offsprings[idx] = self._mutate_chromosome(offsprings[idx], idx)

        # check if the offsprings are valid haar features
        # check = utils.check_features_in_all_haar_fts(
        #     self.ga_instance.train_config.haar_features_viola, offsprings)

        return offsprings